# TAG
Text-to-Audio-Generator

## Bot

**Bot** – это главный сервис программы, в котором происходят все внешние взаимодействия с пользователем.

**context** – это модуль, в котором содержится информация о ID чата, ID пользователя, текстовый запрос о желаемой аудиозаписи и ее продолжительность в секундах. Необходим для поддержания сессии пользователя. 

**sound_request** – это такая абстракция как request, представленная в виде класса, который в качестве атрибутов принимает ID чата, ID пользователя, текстовый запрос о желаемой аудиозаписи и ее продолжительность в секундах, а в качестве методов собирает эти данные в JSON и разбирает данные.

**sender_queue** – это класс, в котором инкапсулируется взаимодействие с программным брокером сообщений RabbitMQ, то есть скрываются тонкости реализации взаимодействия с очередью RabbitMQ, в том числе отправка сообщений в очередь и функция создания очереди. Этот класс упрощает взаимодействие с очередью RabbitMQ в дальнейшем, что позволяет достаточно просто отправлять сообщения в очередь. В качестве атрибута принимает уникальное имя очереди. 

**sound_responce** – это класс, который инкапсулирует (или скрывает) тонкости по разбору и формированию JSON’а, но уже для ответного сообщения, в котором есть ID чата, ID пользователя и сгенерированная по запросу пользователя звукозапись.

**sound_receiver** – это класс, который соединятся с очередью «ResponseQueue», далее из sound_responce она принимает сгенерированную аудиозапись, отправляет ее в Bot и вызывает метод callback, который в свою очередь очищает context, чтобы пользователь мог снова отправить запрос. SoundReceiver работает в отдельном потоке, так как он (SoundReceiver) запускается вместе с ботом, но из-за того, что работа бота останавливает основной поток, то эта часть запускается в отдельном потоке для возможности одновременной работы бота и приема сообщений из очереди. Другими словами, для того чтобы не случилась ситуация, когда один пользователь начал генерацию аудиозаписи, и сервис просто повис и другие пользователи не могли отправить сообщение в бота, SoundReceiver работает в отдельном потоке. 

## Generator Service

GeneratorService – это отдельная программа, которая запускается вместе с ботом параллельно на двух разных машинах (можно и на одной, если хватит мощностей одного компьютера) и включает в себя соответствующие классы и модули:

**sound_generator_service** – это класс, представляющий собой отдельный сервис, который принимает запрос из очереди «RequestQueue», генерирует по нему звук и отправляет в другую очередь «ResponseQueue». Это позволяет не нагружать Bot для того, чтобы бот оперативно отвечал на сообщения пользователей, а сервис мог отдельно генерировать звуки. Так как взаимодействие происходит через очередь, это позволяет потенциально реализовать несколько штук таких сервисов, имеется ввиду что несколько сервисов будут одновременно генерировать звук для разных пользователей. В данной реализации такой сервис один, так как есть ограничения в вычислительных мощностях, но потенциально это возможно в такой архитектуре. В архитектурах без очередей это сделать будет намного сложнее. Таким образом, такая реализация сервиса – это потенциальная возможность для его масштабирования.

**sound_request** – это класс, который в качестве атрибутов принимает ID чата, ID пользователя, текстовый запрос о желаемой аудиозаписи и ее продолжительность в секундах, а в качестве методов собирает эти данные в JSON и разбирает данные, в данном случае он разбирает данные, полученные из очереди.

**model** – это модуль, который является генератором аудиозаписи по текстовому запросу и желаемой продолжительности в секундах. Содержит в себе сложную нейросетевую модель Make-An-Audio, состоящую из нескольких из нейросетей. Более подробная архитектура была описана ранее. 

**sound_responce** – это класс, который скрывает тонкости по разбору и формированию JSON’а, но уже для ответного сообщения, в котором есть ID чата, ID пользователя и сгенерированная по запросу пользователя звукозапись.

**sender_queue** – это класс, в котором, как уже было описано реанее, инкапсулируется взаимодействие с очередью RabbitMQ, то есть скрываются тонкости реализации взаимодействия с очередью RabbitMQ, в том числе отправка сообщений в очередь и функция создания очереди. Этот класс облегчает взаимодействие с очередью RabbitMQ в дальнейшем, что позволяет достаточно просто отправлять сообщения в очередь. В качестве атрибута принимает уникальное имя очереди. 

Таким образом, все вышеописанные компоненты GeneratorService взаимодействуют между собой следующим образом:
SoundGeneratorService соединяется с очередью «RequestQueue», далее он получает из «RequestQueue» все данные, а именно ID пользователя, ID чата, запрос и продолжительность в секундах, в формате JSON, помещает эти данные в SoundRequest, там он их разбирает, потом он отправляет запрос и продолжительность на генерацию с помощью Model, потом полученная звукозапись отправляется в SoundResponce, там собирается в JSON и из SoundResponce отправляется в очередь «ResponseQueue», и так как очередь является отдельным приложением, то по сети она отправляется в очередь, соответственно, с другой стороны, из очереди она забирается SoundReceiver, который отправляет аудиозапись уже в Bot.

## Model

**configs** – это

**env_make_aud** – это

**ldm** – это

**useful_ckpts** – это

**vocoder** – это

**wav_evaluation** – это
 

